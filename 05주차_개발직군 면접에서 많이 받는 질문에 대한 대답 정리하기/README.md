## **1. Binary Search Tree vs Hash Table**

기본적으로 Binary Search Tree와 Hash Table은 모두 키 & 값 형태로 자료를 저장하는 자료구조이다.

그렇기 때문에 사용성 측면에서는 굉장히 유사한 인터페이스를 갖고 있고, 지원하는 연산들도 아주 흡사하다.

그런 이유로, 자주 비교대상이 되는 자료구조로써 각각의 장단점을 한번쯤 정리해볼 필요가 있다.

 

**기능적인 측면**

 

탐색, 삭제, 삽입과 같은 기본기능들에 대해서,

해시 테이블 : O(1) 

이진탐색트리 : O(logN)

정도 성능으로 동작한다.

해시 테이블의 해시 함수의 비용과, 충돌 해결비용까지 고려하더라도 데이터가 엄청 많아지는 경우에는 해시 테이블이 효과적이라고 볼 수 있다. 그리고 만약 입력 사이즈를 알고 있다면, 입력 사이즈에 맞게 최적화된 해시 함수를 이용하여 해시 테이블의 해시 값을 균일하게 분포시켜서 성능을 최적화시킬 수 있을 것이다.

 

하지만 이진탐색트리에는 데이터들의 순서가 정렬된 상태로 유지된다는 강력한 장점이 있다.

이 특성으로 인해 데이터를 정렬된 형태로 순회할 수 있다는 장점도 있겠지만,

아주 좋은 성능으로 범위기반 쿼리가 가능하다는 장점도 있다.

그러므로 순서와 밀접한 연관이 있는 데이터를 다루는 상황에서는 이진탐색트리가 효과적일 것이다.

또한 문자열과 같은 데이터를 다루는 상황에서는 키의 동등 비교를 수행하는 해시 테이블보다, 키의 크기 비교를 수행하는 이진트리가 유리할 것이다.

 

**메모리 측면**

 

메모리 사용량

이진탐색트리는 딱 필요한 원소 만큼의 공간만을 할당하는 반면, 해시 테이블은 해시 적중률을 높이기 위해 원소의 개수 이상의 메모리를 유지해야한다. 그러므로 사용량 측면에서는 이진탐색트리가 유리하다.

 

캐시 적중률

이진탐색트리는 노드 기반 자료구조로 메모리 파편화가 진행되어 캐시 적중률이 떨어지게 된다.

반면, 해시 테이블은 배열 기반 자료구조로 연속된 메모리를 유지하기 때문에 캐시 적중률이 상당히 높다.

 

**결론**

두 자료구조는 외부적으로는 키&값을 사용하는 자료구조로 굉장히 흡사한 인터페이스를 갖고 있지만,

내부적으로는 완전히 다른 형태로 데이터를 관리한다. 그렇기 때문에 어떤 자료구조가 반드시 더 좋다고 결론을 지을 수는 없고, 데이터의 형태나, 환경, 상황에 맞게 적절한 자료구조를 선택하는것이 좋을 것이다.



---



## 2. DFS와 BFS의 장단점

### 깊이 우선 탐색의 장단점

- 장점:
  - 최선의 경우, 가장 빠른 알고리즘이다. ‘운 좋게’ 항상 해에 도달하는 올바른 경로를 선택한다면, *깊이 우선* 탐색이 최소 실행시간에 해를 찾는다.
- 단점:
  - 찾은 해가 최적이 아닐 가능성이 있다.
  - 최악의 경우, 가능한 모든 경로를 탐험하고서야 해를 찾으므로, 해에 도달하는 데 가장 오랜 시간이 걸린다.

### 너비 우선 탐색의 장단점

- 장점:
  - 최적해를 찾음을 보장한다.
- 단점:
  - 최소 실행시간보다는 오래 걸린다는 것이 거의 확실하다.
  - 최악의 경우, 실행에 가장 긴 시간이 걸릴 수 있다.



---



# 3. LRU(Least Recently Used Algorithm)

LRU 알고리즘 : 가장 오랫동안 참조되지 않은 페이지를 교체하는 기법

Cache 알고리즘 중에 가장 유명한 알고리즘 중 하나로 LRU 알고리즘 이라는 것이 있다.

LRU 알고리즘이란 Least Recently Used Algorithm 의 약자로, 캐시에서 메모리를 다루기 위해 사용되는 알고리즘이다.

캐시가 사용하는 리소스의 양은 제한되어 있고, 캐시는 제한된 리소스 내에서 데이터를 빠르게 저장하고 접근할 수 있어야 한다.

이를 위해 LRU 알고리즘은 메모리 상에서 가장 최근에 사용된 적이 없는 캐시의 메모리부터 대체하며 새로운 데이터로 갱신시켜준다.

![img](https://media.vlpt.us/images/courage331/post/eb93b62c-16b1-4865-a61e-a078c436b889/image.png)

LRU 알고리즘의 구현은 위의 그림에서도 볼 수 있듯이 Linked List 를 이용한 Queue 로 이루어지고, 접근의 성능 개선을 위해 Map 을 같이 사용한다.



---



## 4. hash table에 무한한 데이터가 들어온다. 그럼 어떻게 해야 할 것인가?

## 충돌

해시 함수는 **서로 다른 데이터일 때, 서로 다른 해시값을 반환**한다고 하였으나,

사실 정확하게 이렇게 할 수 있는 **해시 함수를 만드는 것은 거의 불가능(비둘기집 원리)**하다.

> **비둘기집 원리** : 5마리 비둘기가 있고 비둘기 집이 4개라면 아무리 균등하게 비둘기를 집에 넣더라도
> 최소한 한 집에는 비둘기가 2마리 이상 들어감.
> **→ 해시 함수가 무한한 가짓수의 입력값을 받아 유한한 가짓수의 출력값을 생성하는 경우**

![img](https://media.vlpt.us/images/roro/post/136bb709-9b2f-4e63-aa27-38ea390fed7d/image.png)

- 첫 글자에 따라 해시값을 반환하는 해시 함수를 만들었다.
  - ex) "A"로 시작하면 **0**, "B"로 시작하면 **1**, "C"로 시작하면 **2** 를 반환
- "APPLE"과 "BANANA"의 가격을 각각 0과 1 Index에 잘 저장했다.
- 그리고 "AVOCADO"를 넣으려고 한다. "A"로 시작해서 0 Index에 넣어야 하는데
  이미 "APPLE"이 공간을 차지하고 있다!?→ **`충돌 (collsion)`**

**`충돌`**을 해결하기 위해 여러 방법이 있는데 가장 간단한 방법은 **같은 `버킷`**에 **여러 개의 키**를 **리스트**로 만든다.

![img](https://media.vlpt.us/images/roro/post/a6dd2ccd-6426-4d2f-b672-6455b74c3e52/image.png)

- "APPLE"과 "AVOCADO"가 같은 버킷에 리스트로 할당되었다.



https://velog.io/@roro/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94

---



## 5. A지하철역에서 B지하철역으로 갈 때 경로를 무슨 알고리즘을 사용할 것인가?

문제 분석: 사실은 무방향도에서 두 노드 간의 가장 짧은 경로를 구하는 것이다.

사고: Dijkstra 알고리즘의 단계는 다음과 같다.
1: 모든 노드를 옮겨다니며 접근하지 않은 노드의 누적 값을 찾습니다. (사실은 원본 노드에서 현재 노드까지의 경로 값과) 가장 작은 (A로 설정).
2: 이 노드의 모든 가달변(목표 노드 B에 연결)을 누적하고 노드 A의 누적권치와 가달변권치가 목표 노드 B 자체의 누적권치보다 작으면 목표 노드 B를 업데이트한다.
3: 노드 A를 액세스하도록 설정합니다.
4: 모든 노드에 대한 액세스가 완료될 때까지 (1)를 반복합니다.
Dijkstra 알고리즘 링크:https://blog.csdn.net/jy7788/article/details/45867577



https://intrepidgeeks.com/tutorial/subway-line-planning-simple-analysis

